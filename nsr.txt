# Nameless Space Replace by viruFac()

```
#!/usr/bin/env python3

import os
import sys
import shutil
import string
```

The script uses basic imports. The main one of note is `string`, which we can use to programatically generate a better dictionary than the following manually entered dictionary:


```python
rm = {' ': '_',
      '[': '',
      ']': '',
      '{': '',
      '}': '',
      '!': '',
      '$': '',
      '&': '',
      '*': '',
      '%': '',
      '@': 'at',
      '(': '',
      ")": '',
      "#": 'no',
      ':': '-',
      ';': '',
      '"': '',
      "'": ''}
```
## Dict key-values are `placeholder-insert` pairs

In this dictionary, the keys are the special characters that do not belong in the filenames of POSIX standard file systems; the values are the characters we would like to have replace them in our file names. 

For the most part this key value will be the blank string I'd think, as you can see in the example. This is why doing it a different way is more than likely easier and less prone to forgetting an important character to check for. 

If you have many sophisticated replacement requirements for each character in your data structure *(which you most likely do not)* then go ahead and enter them manually because that will be easier in that case; otherwise:

```python
rm_keys_list = [char for char in string.punctuation + 
      string.whitespace if not char in "-_+."]
```

If you were to `print(rm)` you would see that a lot of lame characters that should never find their way into a file name are added. You could further add to this by using the UTF-8 ranges of foreign alphabets if you really needed to. But I'm not going to bother looking those up since I don't need to.

```
rm = dict()
for key in rm_keys_list:
   if key == ' ':
      rm[item] = '_'
   else:
      rm[item] = ''
```

You could use a dictionary comprehension for this but since you might like to have several conditionals that would insert something other than the blank string for a given character, this is more readable I think. In the example, we choose to replace spaces with underscores rather than eliminate what that space might represent by replace the blank string, which we can do with most characters easily.

> `rm = {key: '' for key in rm_keys_list}` 

This will work fine if you have no such requirements.


## Onto the Functions

```
def list_dir():
    dir_path = os.getcwd()
    list_files = os.listdir(dir_path)
    return dir_path, list_files
```
In the directory where the script is executed, we will take note of the working directory before we count the quantity of files and directories in that given directory.

```
def divide_files_from_dirs(listed_files):
    listedfiles = []
    listeddirs = []
    for f in listed_files:
        f = os.path.abspath(f)
        if os.path.isdir(f):
            listeddirs.append(f)
            print(f"\tDIRECTORY: {f}")
        elif os.path.isfile(f):
            listedfiles.append(f)
    print("")
    return listedfiles
```

We make two empty lists and iterate over each item in the directory, sorting out the dirs from the files. Adding recursive functionality to this script seems dangerous to me, though I have come to trust it fairly readily if not in system directories (which shouldn't have the problem of bad file naming anyway... 

I still have not added recursive functionality. It seems better to me that way at least.

```
def press_to_cont(msg):
    confirm = input(msg)
    print("")
    if confirm == "QUIT":
        sys.exit(1)
```

This function is mainly to give the user an opt out if they are wanting to test the script and see what exactly it will do but aren't certain they trust it yet. I added it for my own sake while testing it. The program won't tell you this, but you can enter `QUIT` at press to continue states and exit easily.


```
def count(files_to_count, file_types, path):
    print(f"There are {len(files_to_count)} {file_types} in {path}\n")
```

This function is basically to give the user and idea of how many files are getting changed. The numbers and confirmations made it easy for me to tell if something was wrong or off while testing.

```
def list_files(file_list):
    for f in file_list:
        print(f"FILE: {f}")
    print("")
```

Displaying the files helps you feel safe about it also.

```
def relist():
    cwd, ls = list_dir()
    files = divide_files_from_dirs(ls)
    return files
```

Each time that you iterate over the keys in the rm dict for `removal` using the next function, you will have to update your list of files... Otherwise the names will not reflect the changes you made and the program will be confused.

```
def replace_single_char(char_to_remove, char_to_insert, file_list):
    global files_renamed
    files = [f for f in file_list if char_to_remove in f]
    count(files, f"files with '{char_to_remove}'", cwd)
    #press_to_cont("Press to Continue or type 'QUIT' > ")
    for f in files:
        # Alias original filepath
        old = f
        # Make sure only editing relative filepath
        f = f.split(os.sep)
        f = f[-1]
        # cut out characters
        split = f.split(char_to_remove)
        resplit = char_to_insert.join(split)
        new = os.path.abspath(resplit)
        # rename
        shutil.move(old, new)
        files_renamed += 1
    print(f"files with '{char_to_remove}' renamed with '{char_to_insert}'")
    # Make sure that file list reflects changes
    files = relist()
    return files
```

The comments more or less explain the process of replacing the characters.

```
files_renamed = 0
cwd, ls = list_dir()
count(ls, "files and directories", cwd)
files = divide_files_from_dirs(ls)
press_to_cont("""
\tScript does not currently have 
recursive functionality,\n\tso all files inside these 
directories will not be processed.\n\nPress RETURN to Continue or type 'QUIT' >  
""")
count(files, "files to process", cwd)
list_files(files)
for k, v in rm.items():
    files = replace_single_char(k, v, files)

print(f"Process Complete.\n\t{files_renamed} files were renamed")
```

Once you develop the sense of trust in the script and that it's not ever making mistakes that break anything and only misses the most obscure of weird characters that sneak into file names... you will want to make a shell script that goes in your `/bin/` directory. The shell script should point to the permanent path to your nsr.py file. Once in the `/bin/` it will execute the python script from any directory you call `nsr` from.

Bash script is simple as this... I usually remove the `.sh` from the filename so I can call it with only `nsr` 

```bash
#!/bin/bash
exec ~/Git/nameless_space_replace/nsr.py "$@"
```

### Just Please Do Not Use the Shell Script in This Manner in a System Directory with Root or Sudoed Permissions

I'm pretty sure the most likely thing that would happen is you would delete your `lost+found` potentially, but other than that... I think you would be okay. But... don't take any chances.

Hope you enjoyed learning this script.

<https://github.com/virufac/nameless-space-replace/blob/master>
#### -- viruFac


